import ARKit
import PlaygroundSupport
import UIKit
import Vision

// Parameters
let config = MLModelConfiguration()
config.allowLowPrecisionAccumulationOnGPU = true
config.computeUnits = .all
let model = try! best(configuration: config) // Assuming your model class is `best`
let threshold: Float = 0.5

// ViewControllers
final class ViewController: PreviewViewController {
    let classesLabel: UILabel = {
        let label = UILabel()
        label.translatesAutoresizingMaskIntoConstraints = false
        label.textAlignment = .center
        label.backgroundColor = #colorLiteral(red: 0.258823543787003, green: 0.756862759590149, blue: 0.968627452850342, alpha: 0.5)
        label.text = "Nothing is detected."
        return label
    }()

    lazy var request: VNCoreMLRequest = {
        let coreMLModel = try! VNCoreMLModel(for: model.model)
        let request = VNCoreMLRequest(model: coreMLModel, completionHandler: self.processDetections)
        request.imageCropAndScaleOption = .scaleFill
        return request
    }()

    override func viewDidLoad() {
        super.viewDidLoad()

        self.arView.session.delegate = self

        self.view.addSubview(self.classesLabel)

        NSLayoutConstraint.activate([
            self.classesLabel.bottomAnchor.constraint(equalTo: self.liveViewSafeAreaGuide.bottomAnchor),
            self.classesLabel.leadingAnchor.constraint(equalTo: self.liveViewSafeAreaGuide.leadingAnchor),
            self.classesLabel.trailingAnchor.constraint(equalTo: self.liveViewSafeAreaGuide.trailingAnchor),
        ])
    }

    func detect(imageBuffer: CVImageBuffer, orientation: CGImagePropertyOrientation) {
        try! VNImageRequestHandler(cvPixelBuffer: imageBuffer, orientation: orientation)
            .perform([self.request])
    }

    func processDetections(for request: VNRequest, error: Error?) {
        guard let results = request.results as? [VNCoreMLFeatureValueObservation],
              let feature = results.first?.featureValue.multiArrayValue else {
            self.classesLabel.text = "Nothing detected."
            return
        }

        let (boundingBox, mask) = self.parseYOLOOutput(feature)

        DispatchQueue.main.async {
            self.drawBoundingBox(boundingBox)
            self.drawMask(mask)
        }
    }

    func parseYOLOOutput(_ feature: MLMultiArray) -> (CGRect, [[Float]]) {
        var maxProb: Float = 0
        var boundingBox: CGRect = .zero
        var bestMaskProb: Int = 0

        for j in 0..<(feature.shape[2].intValue - 2) {
            let key = [0, 4, j] as [NSNumber]
            let nextKey = [0, 4, j + 1] as [NSNumber]
            if feature[key].floatValue < feature[nextKey].floatValue {
                if maxProb < feature[nextKey].floatValue {
                    bestMaskProb = j + 1
                    let xKey = [0, 0, bestMaskProb] as [NSNumber]
                    let yKey = [0, 1, bestMaskProb] as [NSNumber]
                    let widthKey = [0, 2, bestMaskProb] as [NSNumber]
                    let heightKey = [0, 3, bestMaskProb] as [NSNumber]
                    maxProb = feature[nextKey].floatValue
                    let boxWidth = feature[widthKey].floatValue
                    let boxHeight = feature[heightKey].floatValue
                    let boxX = feature[xKey].floatValue - (boxWidth / 2)
                    let boxY = feature[yKey].floatValue - (boxHeight / 2)
                    boundingBox = CGRect(x: CGFloat(boxX), y: CGFloat(boxY), width: CGFloat(boxWidth), height: CGFloat(boxHeight))
                }
            }
        }

        return (boundingBox, extractMask(feature: masks, bestMaskProb: bestMaskProb))
    }

    func extractMask(feature: MLMultiArray, bestMaskProb: Int) -> [[Float]] {
        var maskProbabilities: [[Float]] = []
        let maskProbThreshold: Float = 0.5

        for y in 0..<feature.shape[2].intValue {
            var maskProbYAxis: [Float] = []
            for x in 0..<feature.shape[3].intValue {
                let pointKey = [0, bestMaskProb, y, x] as [NSNumber]
                if sigmoid(z: feature[pointKey].floatValue) < maskProbThreshold {
                    maskProbYAxis.append(1.0)
                } else {
                    maskProbYAxis.append(0.0)
                }
            }
            maskProbabilities.append(maskProbYAxis)
        }

        return maskProbabilities
    }

    func sigmoid(z: Float) -> Float {
        return 1.0 / (1.0 + exp(z))
    }

    func drawBoundingBox(_ boundingBox: CGRect) {
        // Drawing code for bounding box
    }

    func drawMask(_ mask: [[Float]]) {
        // Drawing code for mask
    }
}

extension ViewController: ARSessionDelegate {
    func session(_ session: ARSession, didUpdate frame: ARFrame) {
        self.detect(
            imageBuffer: frame.capturedImage,
            orientation: CGImagePropertyOrientation(interfaceOrientation: UIScreen.main.orientation)
        )
    }
}

PlaygroundPage.current.wantsFullScreenLiveView = true
PlaygroundPage.current.liveView = ViewController()